import os
import torch
import matplotlib.pyplot as plt
import pandas as pd
import umap
from torch.utils.data import DataLoader
from sklearn.manifold import TSNE

from datasets.adni_3d import ADNI_3D
from datasets.augmentations import BatchedAugment
from models.build_model import *




def get_embeddings(model_path, dst, embed_type='tsne'):
    '''
    Computes tsne/umap embeddings and saves as csv file

    Args:
        model_path: Path to pretrained Pytorch model
        dst: Path to save csv containing embeddings
    
    Keyword Args:
        embed_type: TSNE or UMAP embeddings. Default=tsne
                    Expects one of [tsne, umap]
    '''

    root = '/home/jacob/Documents/ADNI'
    weights = os.path.join(model_path, 'last_model.pt')

    train_dataset = ADNI_3D(dir_to_scans=os.path.join(root, 'mni'),
                        dir_to_tsv=os.path.join(root, 'tabular_data'),
                        dir_type='bids',
                        mode='Train',
                        n_label=3,
                        percentage_usage=1)

    val_dataset = ADNI_3D(dir_to_scans=os.path.join(root, 'mni'),
                        dir_to_tsv=os.path.join(root, 'tabular_data'),
                        dir_type='bids',
                        mode='Val',
                        n_label=3,
                        percentage_usage=1)

    test_dataset = ADNI_3D(dir_to_scans=os.path.join(root, 'mni'),
                        dir_to_tsv=os.path.join(root, 'tabular_data'),
                        dir_type='bids',
                        mode='Test',
                        n_label=3,
                        percentage_usage=1)

    train_dataloader = DataLoader(train_dataset, batch_size=4)
    val_dataloader = DataLoader(val_dataset, batch_size=4)
    test_dataloader = DataLoader(test_dataset, batch_size=4)

    model = prepare_model(mri_out=1024, head_hid=512, head_out=128, head_type='Single', multimodal=False)
    model = load_weights(model, weights)
    # model.head = torch.nn.Identity()

    model.to('cuda')
    model.eval()

    augmenter = BatchedAugment()
    events = []
    times = []
    splits = []

    embs = torch.empty(0, 128)
    for split, dl in zip(['train', 'val', 'test'], [train_dataloader, val_dataloader, test_dataloader]):
        for img, _, e, t, _ in dl:
            X = augmenter(img, mode='test').to('cuda')
            events += e.tolist()
            times += t.tolist()
            splits += [split]*len(e)

            proj = model(X).detach().cpu()

            embs = torch.cat([embs, proj], dim=0)

    if embed_type == 'umap':
        proj = umap.UMAP(n_neighbors=3,
                    min_dist=0.1,
                    metric='cosine').fit_transform(embs)

    elif embed_type == 'tsne':
        tsne = TSNE(n_components=2, verbose=1, perplexity=40, n_iter=300)
        proj = tsne.fit_transform(embs)
    else:
        raise ValueError(f'Expected "embed_type" to be one of [umap, tsne], got {embed_type}')


    df = pd.DataFrame({
        'events': events,
        'times': times,
        'splits': splits, 
        'proj-one': proj[:, 0],
        'proj-two': proj[:, 1]
    })

    df.to_csv(dst)

def plot_embeddings(df_path, dst, split=None, model='TE-SSL', plot_censors=False):
    '''
    Plots embeddings generated by tsne/umap algorithms

    Args:
        df_path: Path to csv file containing embeddings
        dst: Path to save figures
        
    Keyword Args:
        split: Plot Train/test split, Default=None
                Expects one of [train, val, test]
        model: model name
        plot_censores: Plot censored data? Default=False
    '''
    df = pd.read_csv(df_path)

    fig = plt.figure(figsize=(7, 7), dpi=300)

    if split:
        df = df[df['splits'] == split]
    pos = df[df['events'] == True]




    colors = ['blue', 'green', 'red']
    prev = 0
    times = [18, 36, 66]
    for t, color in zip(times, colors):
        temp = pos[pos['times'] >= prev]
        temp = temp[temp['times'] < t]
        plt.scatter(temp['proj-one'], temp['proj-two'], c=color, label=f'Times: [{prev},{t})', alpha=.9)
        prev = t


    if plot_censors:
        neg = df[df['events'] == False]
        plt.scatter(neg['proj-one'], neg['proj-two'], c='grey', label=f'Censored', alpha=.8)

    plt.legend()
    if split is None:
        plt.title(f'T-SNE visualization {model}', fontsize=15)
    else:
        plt.title(f'T-SNE visualization {model} ({split})', fontsize=15)

    plt.tick_params(left = False, right = False , labelleft = False , 
                labelbottom = False, bottom = False) 
    fig.tight_layout()
    fig.savefig(dst)



if __name__ == '__main__':
    # get_embeddings(model_path='figures/pretrain/self/1', dst='figures/self_embeddings.csv')
        
    plot_censors = True
    df_path = 'figures/te-ssl_embeddings.csv'
    model = 'TE-SSL'
    dst = 'figures/viz/te-ssl'
    plot_embeddings(df_path=df_path, dst=os.path.join(dst, f'{model}-{str(plot_censors)}_train.png'), split='train', model=model, plot_censors=plot_censors)
    plot_embeddings(df_path=df_path, dst=os.path.join(dst, f'{model}-{str(plot_censors)}_val.png'), split='val', model=model, plot_censors=plot_censors)
    plot_embeddings(df_path=df_path, dst=os.path.join(dst, f'{model}-{str(plot_censors)}_all.png'), split=None, model=model, plot_censors=plot_censors)
    plot_embeddings(df_path=df_path, dst=os.path.join(dst, f'{model}-{str(plot_censors)}_test.png'), split='test', model=model, plot_censors=plot_censors)